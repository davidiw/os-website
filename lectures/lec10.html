<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

    <title>CS422/522 - Lecture 10 - File Systems</title>

    <meta name="description" content="Lecture 10 - File Systems<">
    <meta name="author" content="David Wolinsky">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'reveal.js/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

    <script>
var m_current = 0;

var m_outline = [
  "Recap",
  "File System Strawman",
  "File System Reads",
  "File System Writes",
  "Other Types of Files Systems",
  "Wrap-Up"
  ];

function writeOutline() {
  var count = m_outline.length;
  var trigger = m_current / count;

  document.write("<section>");
  document.write("<h3>Outline</h3>");
  document.write("<ol>");
  for(i = 0; i < count; i++, m_current++) {
    var opacity = 0.4;
    if (m_current % count == trigger) {
      opacity = 1.0;
    }
    document.write("<li style=\"opacity: " + opacity + ";\">" + m_outline[i] + "</li>");
  }
  document.write("</ol>");
  document.write("</section>");
}
    </script>

    <style>
      .reveal pre code { max-height: 700px; }
      .reveal pre { font-size: 70%; }
      .reveal p { text-align: left; }
    </style>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
  <!--
        <section>
          <h3>Divided</h3>
          <div style="width: 100%">
            <div style="width: 50%; float: left;">
            </div>
            <div style="width: 50%; float: left;">
            </div>
          </div>
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3></h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
          </code></pre>
        </section>
  -->
				<section>
          <h2>File Systems</h2>
          <h3>CS422/522 Lecture 10</h3>
          <h3>13 October 2014</h3>
          <h4>Last updated: 13 October 2014</h4>
				</section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>Recap</h3>
          <ul>
            <li>Inteprocess Communication</li>
            <li>Modularity, scalability, security, etc</li>
            <li>Direct vs Indirect</li>
            <li>Blocking vs non-blocking</li>
          </ul>
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>Why File Systems</h3>
          <ul class="fragment">
            <li>Structured approach to storing contents on disk</li>
            <li>Common interface to accessing persistent data</li>
          </ul>
        </section>

        <section>
          <h3>The Path</h3>
          <ul>
            <li>Files -- basic unit of storage</li>
            <li>Directories -- separate files and directories into collections</li>
            <li>File systems / partitions / drives</li>
          </ul> <p />
          <div class="fragment">
          <h4>Representation</h4>
          <ul>
            <li>Windows: drive:\folder\file</li>
            <li>Linux: /folder/file</li>
            <li>Linux: /boot/kernel</li>
          </ul>
        </section>

        <section>
          <h3>Simple File System</h3>
          <ul>
            <li>User-layer file system interface</li>
            <li>File system aware data structure</li>
            <li>Disk</li>
          </ul>
        </section>

        <section>
          <h3>Basic Operations on FIles</h3>
          <ul>
            <li>Open -- fd = open(path, flags, mode)</li>
            <li>Close -- close(fd)</li>
            <li>Write -- write(fd, data, strlen(data))</li>
            <li>Read -- read(fd, &ampbuf, buflen)</li>
            <li>Seek -- lseek(fd, offset, SEEK_CUR)</li>
            <li>Information -- fstat(fd, &ampstat)</li>
          </ul>
        </section>

        <section>
          <h3>File System Layout</h3>
          Made up of blocks / sectors -- 512 to 4,096 bytes<br />
          <div class="fragment">
            <ul>
              <li>Booting an OS</li>
              <li>Size of disk</li>
              <li>Data organization</li>
              <li>Free space</li>
            </ul> <br />
            <img src="images/fs-struct.png" />
          </div>
        </section>

        <section>
          <h3>Boot sector</h3>
          <ul>
            <li>Master boot record</li>
            <li>BIOS reads this sector into memory at 0x7c00</li>
            <li>BIOS jumps to 0x7c00 begins executing</li>
            <li>Must be able to find kernel in FS</li>
            <li>Can be OS specific or generic</li>
          </ul>
        </section>

        <section>
          <h3>Super block</h3>
          <ul>
            <li>Disk metadata</li>
            <li>File system parameters</li>
            <li>number of inodes</li>
            <li>number of data blocks</li>
          </ul>
        </section>

        <section>
          <h3>Inodes</h3>
          Metadata about files and directories
          <ul class="fragment">
            <li>mode -- permissions</li>
            <li>owner</li>
            <li>access / creation / modification time</li>
            <li>size</li>
            <li>direct maps</li>
            <li>indirect maps</li>
          </ul>
          <div class="fragment">Why indirect maps</div>
        </section>

        <section>
          <h3>Inode data</h3>
          <ul>
            <li>File -- raw binary data store in blocks</li>
            <li>Directory -- <span class="fragment">file containing a sequence of names</span></li>
          </ul>
        </section>

        <section>
          <h3>File Descriptors</h3>
          <ul>
            <li>User-space -- integer</li>
            <li>Kernel-space:
              <ul>
                <li>inode</li>
                <li>current offset in file</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Strawman Example</h3>
          <ul>
            <li>/home is mount of a file system</li>
            <li>ls -a /home/davidiw/hw5.sol</li>
          </ul> <p />
          <h4>The Process</h4>
          <ul>
            <li>lstat("/home/davidiw/hw5.sol", &ampstat)</li>
            <li>OS first accesses the inode for / in the file system mounted on /home</li>
            <li>Scan the directory for davidiw</li>
            <li>Access inode for davidiw, scan for hw5.sol</li>
            <li>read hw5.sol and return its attributes in stat</li>
          </ul>
        </section>

        <section>
          <h3>File System Challenges</h3>
          <ul class="fragment">
            <li>User interface</li>
            <li>Performance</li>
            <li>Reliability</li>
            <li>Protection</li>
            <li>Sharing</li>
            <li>Sychronization</li>
          </ul>
        </section>

        <section>
          <h3>A More Practical FS Approach</h3>
          <ul>
            <li>File descriptor -- user / kernel interfacee</li>
            <li>Pathname</li>
            <li>Directory</li>
            <li>Inode</li>
            <li>Logging -- reliability</li>
            <li>Buffer cache -- performance / sychronization</li>
            <li>Disk</li>
          </ul> <br />
          <img src="images/fs-struct-log.png" />  <br />
          We extend superblock to contain number of log entries
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>Buffer Cache</h3>
          <ul>
            <li>Magnetic Disk operations: 2 to 20 ms</li>
            <li>Flash Disk operations: 25 to 250 us</li>
            <li>Memory operations: 20 to 50 ns</li>
            <li>How many blocks to cache?</li>
            <li>Cache eviction/replacement</li>
            <li>Useful for sharing</li>
          </ul>
        </section>

        <section>
          <h3>Xv6 Read Example</h3>
          cat /home/davidiw/hw5.sol <br />
          <ul>
            <li>fd = open("/home/davidiw/hw5.sol", O_RDONLY)</li>
            <li>Scan / inode for home</li>
            <li>Scan home inode for davidiw</li>
            <li>Scan davidiw for hw5.sol</li>
            <li>Read hw5.sol inode into a buffer</li>
            <li>Allocate a fd with the inode info and return to user</li>
            <li>read(fd, ...)
            <li>Read hw5.sol data from disk into buffer and then print on screen</li>
          </ul>
        </section>

        <section>
          <h3>User / Kernel Interface</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
6101 sys_open(void)
6120   if((ip = namei(path)) == 0){ .. }
6124   ilock(ip);
6132   if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt 0) { ... }
...
6139   iunlock(ip);
6142   f−>type = FD_INODE;
6143   f−>ip = ip;
6144   f−>off = 0;
6145   f−>readable = !(omode & O_WRONLY);
6146   f−>writable = (omode & O_WRONLY) || (omode & O_RDWR);
6147   return fd;
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 1</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5539 struct inode*
5540 namei(char *path)
5541 {
5542   char name[DIRSIZ];
5543   return namex(path, 0, name);
5544 }
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 2</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5504 static struct inode*
5505 namex(char *path, int nameiparent, char *name)
5506 {
5507   struct inode *ip, *next;
5508
5509   if(*path == ’/’)
5510     ip = iget(ROOTDEV, ROOTINO);
...
          </code></pre>
        </section>

        <section>
          <h3>inode cache</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5004 iget(uint dev, uint inum)
5006   struct inode *ip, *empty;
5008   acquire(&icache.lock);
5011   empty = 0;
5012   for(ip = &icache.inode[0]; ip &lt &icache.inode[NINODE]; ip++){
5013     if(ip−>ref > 0 && ip−>dev == dev && ip−>inum == inum){
5014       ip−>ref++;
5015       release(&icache.lock);
5016       return ip;
5017     }
5018     if(empty == 0 && ip−>ref == 0) // Remember empty slot.
5019       empty = ip;
5020   }
5026   ip = empty;
5027   ip−>dev = dev;
5028   ip−>inum = inum;
5029   ip−>ref = 1;
5030   ip−>flags = 0;
5031   release(&icache.lock);
5033   return ip;
          </code></pre>
        </section>

        <section>
          <h3>struct inode</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4011 // in−memory copy of an inode
4012 struct inode {
4013   uint dev; // Device number
4014   uint inum; // Inode number
4015   int ref; // Reference count
4016   int flags; // I_BUSY, I_VALID
4017
4018   short type; // copy of disk inode
4019   short major;
4020   short minor;
4021   short nlink;
4022   uint size;
4023   uint addrs[NDIRECT+1];
4024 };
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 3</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5504 static struct inode*
5505 namex(char *path, int nameiparent, char *name)
5506 {
5507   struct inode *ip, *next;
5508
5509   if(*path == ’/’)
5510     ip = iget(ROOTDEV, ROOTINO);
...
5514   while((path = skipelem(path, name)) != 0){
5515     ilock(ip);
          </code></pre>
        </section>

        <section>
          <h3>Locking inodes</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5053 ilock(struct inode *ip)
5054 {
5055   struct buf *bp;
5056   struct dinode *dip;
5061   acquire(&icache.lock);
5062   while(ip−>flags & I_BUSY)
5063     sleep(ip, &icache.lock);
5064   ip−>flags |= I_BUSY;
5065   release(&icache.lock);
// read if not valid
5081 }
          </code></pre>
        </section>

        <section>
          <h3>Read if not valid</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5067   if(!(ip−>flags & I_VALID)){
5068     bp = bread(ip−>dev, IBLOCK(ip−>inum));
5069     dip = (struct dinode*)bp−>data + ip−>inum%IPB;
5070     ip−>type = dip−>type;
5071     ip−>major = dip−>major;
5072     ip−>minor = dip−>minor;
5073     ip−>nlink = dip−>nlink;
5074     ip−>size = dip−>size;
5075     memmove(ip−>addrs, dip−>addrs, sizeof(ip−>addrs));
5076     brelse(bp);
5077     ip−>flags |= I_VALID;
5080   }
          </code></pre>
        </section>

        <section>
          <h3>Block reading</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4401 struct buf*
4402 bread(uint dev, uint sector)
4403 {
4404   struct buf *b;
4405
4406   b = bget(dev, sector);
4407   if(!(b−>flags & B_VALID))
4408     iderw(b);
4409   return b;
4410 }
          </code></pre>
        </section>

        <section>
          <h3>bget cached</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4365 static struct buf*
4366 bget(uint dev, uint sector)
4367 {
4368   struct buf *b;
4370   acquire(&bcache.lock);
4371
4372   loop:
4374   for(b = bcache.head.next; b != &bcache.head; b = b−>next){
4375     if(b−>dev == dev && b−>sector == sector){
4376       if(!(b−>flags & B_BUSY)){
4377         b−>flags |= B_BUSY;
4378         release(&bcache.lock);
4379         return b;
4380       }
4381       sleep(b, &bcache.lock);
4382       goto loop;
4383     }
4384   }
          </code></pre>
        </section>

        <section>
          <h3>Not Cached</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4389   for(b = bcache.head.prev; b != &bcache.head; b = b−>prev){
4390     if((b−>flags & B_BUSY) == 0 && (b−>flags & B_DIRTY) == 0){
4391       b−>dev = dev;
4392       b−>sector = sector;
4393       b−>flags = B_BUSY;
4394       release(&bcache.lock);
4395       return b;
4396     }
4397   }
4398   return 0;
4399 }
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 4</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5504 static struct inode*
5505 namex(char *path, int nameiparent, char *name)
5506 {
5507   struct inode *ip, *next;
5508
5509   if(*path == ’/’)
5510     ip = iget(ROOTDEV, ROOTINO);
...
5514   while((path = skipelem(path, name)) != 0){
5515     ilock(ip);
5525     if((next = dirlookup(ip, name, 0)) == 0){
5526       iunlockput(ip);
5527       return 0;
5528     }
5529     iunlockput(ip);
5530     ip = next;
5531   }
5536   return ip;
5537 }
          </code></pre>
        </section>

        <section>
          <h3>Looking up directories</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5361 dirlookup(struct inode *dp, char *name, uint *poff)
5362 {
5363   uint off, inum;
5364   struct dirent de;
5369   for(off = 0; off &lt dp−>size; off += sizeof(de)){
5370     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5371       panic("dirlink read");
5372     if(de.inum == 0)
5373       continue;
5374     if(namecmp(name, de.name) == 0){
5375     // entry matches path element
5376       if(poff)
5377         *poff = off;
5378       inum = de.inum;
5379       return iget(dp−>dev, inum);
5380     }
5381   }
5383   return 0;
5384 }
          </code></pre>
        </section>

        <section>
          <h3>struct dirent</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
3950 struct dirent {
3951   ushort inum;
3952   char name[DIRSIZ];
3953 };
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 5 -- data</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5252 readi(struct inode *ip, char *dst, uint off, uint n)
5253 {
5254   uint tot, m;
5255   struct buf *bp;
5256
5268   for(tot=0; tot&ltn; tot+=m, off+=m, dst+=m){
5269     bp = bread(ip−>dev, bmap(ip, off/BSIZE));
5270     m = min(n − tot, BSIZE − off%BSIZE);
5271     memmove(dst, bp−>data + off%BSIZE, m);
5272     brelse(bp);
5273   }
5274   return n;
5275 }
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 6 -- the block address</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5160 bmap(struct inode *ip, uint bn)
5161 {
5162   uint addr, *a;
5163   struct buf *bp;
5164
5165   if(bn &lt NDIRECT){
5166     if((addr = ip−>addrs[bn]) == 0)
5167     ip−>addrs[bn] = addr = balloc(ip−>dev);
5168     return addr;
5169   }
          </code></pre>
        </section>

        <section>
          <h3>Reading inode part 6 -- the block address (indirect)</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5170   bn −= NDIRECT;
5172   if(bn &lt NINDIRECT){
5176     bp = bread(ip−>dev, addr);
5177     a = (uint*)bp−>data;
5178     if((addr = a[bn]) == 0){ ... }
5182     brelse(bp);
5183     return addr;
5184   }
5187 }
          </code></pre>
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>File System Logs</h3>
          Transactions <br />
          <ul>
            <li>Series of writes</li>
            <li>Atomic -- all or none</li>
            <li>Prevents stale file system state, despite crashes</li>
            <li>Supports batching</li>
          </ul>
        </section>

        <section>
          <h3>File System Logs in Action</h3>
          <ul>
            <li>Update a buffer cache</li>
            <li>Set in-memory log to write to disk</li>
            <li>Release for other readers / writers</li>
            <li>...</li>
            <li>Write log to on-disk log</li>
            <li>Write log header to on-disk log header</li>
            <li>Write content to disk data</li>
            <li>Remove log header</li>
          </ul>
        </section>

        <section>
          <h3>Fault Tolerance</h3>
          <ul>
            <li>Empty log header: <span class="fragment">all committed or interrupted</span></li>
            <li>Log header: <span class="fragment">interrupted before copying to data</span></li>
          </ul>
        </section>

        <section>
          <h3>Recovering from Log</h3>
          <ul>
            <li>Found non-empty log header</li>
            <li>Read header</li>
            <li>Store log contents into data</li>
            <li>What happens to partially committed data</li>
          </ul>
        </section>

        <section>
          <h3>Xv6 Write Example</h3>
          echo "Hello, World" &gt /home/davidiw/test <br />
          <ul>
            <li>open("/home/davidiw/hw5.sol", O_CREAT | O_WRONLY)</li>
            <li>Scan / inode for home ...</li>
            <li>Find a free inode, create file shell</li>
            <li>Update directory with new file entry</li>
            <li>Return fd return to echo, echo perofms write(fd, ...)</li>
            <li>Start a new transaction</li>
            <li>Write (update) contents into 1 or more buffers</li>
            <li>End transaction</li>
            <li>Transaction queued</li>
            <li>Write to disk log</li>
            <li>Write to disk</li>
            <li>Erase log</li>
          </ul>
        </section>

        <section>
          <h3>Creating a file</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
6101 sys_open(void)
6111   begin_op();
6113   if(omode & O_CREATE){
6114     ip = create(path, T_FILE, 0, 0);
...
6132   if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt 0){ ... }
6139   iunlock(ip);
6140   end_op();
6141
6142   f−>type = FD_INODE;
6143   f−>ip = ip;
6144   f−>off = 0;
6145   f−>readable = !(omode & O_WRONLY);
6146   f−>writable = (omode & O_WRONLY) || (omode & O_RDWR);
6147   return fd;
          </code></pre>
        </section>

        <section>
          <h3>Inode and directory</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
6057 create(char *path, short type, short major, short minor)
6063   if((dp = nameiparent(path, name)) == 0)
6064     return 0;
6065   ilock(dp);
6076   if((ip = ialloc(dp−>dev, type)) == 0)
6077     panic("create: ialloc");
6078
6079   ilock(ip);
6080   ip−>major = major;
6081   ip−>minor = minor;
6082   ip−>nlink = 1;
6083   iupdate(ip);
6092
6093   if(dirlink(dp, name, ip−>inum) &lt 0)
6094     panic("create: dirlink");
6096   iunlockput(dp);
6098   return ip;
          </code></pre>
        </section>

        <section>
          <h3>Allocating an inode</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4953 ialloc(uint dev, short type)
4960   readsb(dev, &sb);
4962   for(inum = 1; inum &lt sb.ninodes; inum++){
4963     bp = bread(dev, IBLOCK(inum));
4964     dip = (struct dinode*)bp−>data + inum%IPB;
4965     if(dip−>type == 0){ // a free inode
4966       memset(dip, 0, sizeof(*dip));
4967       dip−>type = type;
4968       log_write(bp); // mark it allocated on the disk
4969       brelse(bp);
4970       return iget(dev, inum);
4971     }
4972     brelse(bp);
4973   }
          </code></pre>
        </section>

        <section>
          <h3>Updating a directory</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5402 dirlink(struct inode *dp, char *name, uint inum)
5409   if((ip = dirlookup(dp, name, 0)) != 0){ ... }
5415   for(off = 0; off &lt dp−>size; off += sizeof(de)){
5416     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5417       panic("dirlink read");
5418     if(de.inum == 0)
5419       break;
5420   }
5422   strncpy(de.name, name, DIRSIZ);
5423   de.inum = inum;
5424   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5425     panic("dirlink");
5427   return 0;
          </code></pre>
        </section>

        <section>
          <h3>Writing data to an inode</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
5302 writei(struct inode *ip, char *src, uint off, uint n)
5318   for(tot=0; tot&ltn; tot+=m, off+=m, src+=m){
5319     bp = bread(ip−>dev, bmap(ip, off/BSIZE));
5320     m = min(n − tot, BSIZE − off%BSIZE);
5321     memmove(bp−>data + off%BSIZE, src, m);
5322     log_write(bp);
5323     brelse(bp);
5324   }
5326   if(n > 0 && off > ip−>size){
5327     ip−>size = off;
5328     iupdate(ip);
5329   }
5330   return n;
          </code></pre>
        </section>

        <section>
          <h3>Updating an inode</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4979 iupdate(struct inode *ip)
4984   bp = bread(ip−>dev, IBLOCK(ip−>inum));
4985   dip = (struct dinode*)bp−>data + ip−>inum%IPB;
4986   dip−>type = ip−>type;
4987   dip−>major = ip−>major;
4988   dip−>minor = ip−>minor;
4989   dip−>nlink = ip−>nlink;
4990   dip−>size = ip−>size;
4991   memmove(dip−>addrs, ip−>addrs, sizeof(ip−>addrs));
4992   log_write(bp);
4993   brelse(bp);
          </code></pre>
        </section>

        <section>
          <h3>This whole notion of logging</h3>
          <ul>
            <li>We have not seen a bwrite</li>
            <li>We have seen begin_op, log_write, end_op</li>
            <li>These act as a logging layer to bwrite</li>
          </ul>
        </section>

        <section>
          <h3>Starting a transaction</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4628 begin_op(void)
4630   acquire(&log.lock);
4631   while(1){
4632     if(log.committing){
4633     sleep(&log, &log.lock);
4634     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4635       // this op might exhaust log space; wait for commit.
4636       sleep(&log, &log.lock);
4637     } else {
4638       log.outstanding += 1;
4639       release(&log.lock);
4640       break;
4641     }
4642   }
          </code></pre>
        </section>

        <section>
          <h3>Writing to the log</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4722 log_write(struct buf *b)
4726   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size − 1)
4727     panic("too big a transaction");
4728   if (log.outstanding &lt 1)
4729     panic("log_write outside of trans");
4730
4731   for (i = 0; i &lt log.lh.n; i++) {
4732     if (log.lh.sector[i] == b−>sector) // log absorbtion
4733     break;
4734   }
4735   log.lh.sector[i] = b−>sector;
4736   if (i == log.lh.n)
4737     log.lh.n++;
4738   b−>flags |= B_DIRTY; // prevent eviction
          </code></pre>
        </section>

        <section>
          <h3>Ending the Transaction</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4653 end_op(void)
4655   int do_commit = 0;
4657   acquire(&log.lock);
4661   if(--log.outstanding == 0){
4662     do_commit = 1;
4663     log.committing = 1;
4664   } else {
4666     wakeup(&log);
4667   }
4668   release(&log.lock);
4669
4670   if(do_commit){
4673     commit();
4674     acquire(&log.lock);
4675     log.committing = 0;
4676     wakeup(&log);
4677     release(&log.lock);
4678   }
          </code></pre>
        </section>

        <section>
          <h3>Making a Commitment</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4701 commit()
4703   if (log.lh.n > 0) {
4704     write_log(); // Write modified blocks from cache to log
4705     write_head(); // Write header to disk −− the real commit
4706     install_trans(); // Now install writes to home locations
4707     log.lh.n = 0;
4708     write_head(); // Erase the transaction from the log
4709   }
          </code></pre>
        </section>

        <section>
          <h3>Writing the Log</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4683 write_log(void)
4687   for (tail = 0; tail &lt log.lh.n; tail++) {
4688     struct buf *to = bread(log.dev,
           log.start+tail+1); // log block
4689     struct buf *from = bread(log.dev,
           log.lh.sector[tail]); // cache block
4690     memmove(to−>data, from−>data, BSIZE);
4691     bwrite(to); // write the log
4692     brelse(from);
4693     brelse(to);
4694   }
          </code></pre>
        </section>

        <section>
          <h3>Writing to the Disk</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4414 bwrite(struct buf *b)
4416   if((b−>flags & B_BUSY) == 0)
4417     panic("bwrite");
4418   b−>flags |= B_DIRTY;
4419   iderw(b);
          </code></pre>
        </section>

        <section>
          <h3>Writing the Log Head</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4604 write_head(void)
4606   struct buf *buf = bread(log.dev, log.start);
4607   struct logheader *hb = (struct logheader *) (buf−>data);
4608   int i;
4609   hb−>n = log.lh.n;
4610   for (i = 0; i &lt log.lh.n; i++) {
4611     hb−>sector[i] = log.lh.sector[i];
4612   }
4613   bwrite(buf);
4614   brelse(buf);
          </code></pre>
        </section>

        <section>
          <h3>Completing the Transaction</h3>
          <pre><code class="cpp" data-noescape="true" data-trim="true">
4572 install_trans(void)
4574   int tail;
4575
4576   for (tail = 0; tail &lt log.lh.n; tail++) {
4577     struct buf *lbuf = bread(log.dev,
           log.start+tail+1); // read log block
4578     struct buf *dbuf = bread(log.dev,
           log.lh.sector[tail]); // read dst
4579     memmove(dbuf−>data, lbuf−>data, BSIZE); // copy block to dst
4580     bwrite(dbuf); // write dst to disk
4581     brelse(lbuf);
4582     brelse(dbuf);
4583   }
          </code></pre>
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>Other Types of Files Systems</h3>
          <ul class="fragment">
            <li>Pipes</li>
            <li>Devices (devfs)</li>
            <li>System state: procfs, sysfs</li>
            <li>Log / transaction</li>
            <li>Database</li>
            <li>Tape</li>
            <li>Flash</li>
            <li>Network file systems</li>
            <li>FUSE</li>
          </ul>
        </section>

        <section>
          <h3>Devices</h3>
          <ul>
            <li>Character -- direct / unbuffered</li>
            <li>Block -- indirect / buffered</li>
            <li>/dev/null -- writes are discarded, nothing to read</li>
            <li>/dev/zero -- writes are discarded, reads return NUL</li>
            <li>/dev/full -- unable to write, returns NUL</li>
            <li>/dev/random | /dev/urandom -- pseudo-random streams</li>
            <li>/dev/sda | /dev/hda -- hard disks</li>
          </ul>
        </section>

        <section>
          <h3>procfs</h3>
          <ul>
            <li>Found under /proc</li>
            <li>Process information /proc/$PID</li>
            <li>OS information</li>
            <li>Uptime</li>
            <li>Network settings</li>
            <li>Set -- echo $VALUE &gt file</li>
            <li>Rad -- cat file</li>
          </ul>
        </section>

        <section>
          <h3>sysfs</h3>
          <ul>
            <li>Similar to procfs / devfs</li>
            <li>Emphasis on unified driver / device</li>
            <li>Change brightness on a laptop display: <br />
              cat /sys/class/backlight/intel_backlight/max_brightness &gt
              /sys/class/backlight/intel_backlight/brightness
            </li>
          </ul>
        </section>

        <section>
          <h3>Transactional File System</h3>
          <ul>
            <li>Log in xv6 offers: <span class="fragment">atomic writes</span></li>
            <li>Never overwrite contents, requires garbage collection</li>
            <li>All writes should be written sequentially, like xv6 log</li>
            <li>Many writes can be issued together -- transaction</li>
          </ul> <br />
          <img src="images/lfs.png"/>
        </section>

        <section>
          <h3>Database</h3>
          <ul>
            <li>What happens if we insert or delete content from the middle of a file?
              <span class="fragment">entire file must be updated from that point on</span></li>
            <li class="fragment">Databases can store large objects using B-tree: <br />
              <img src="images/btree.png" />
            </li>
            <li class="fragment">b-tree contains meta-data including offset and size</li>
            <li class="fragment">data is variable size</li>
          </ul>
        </section>

        <section>
          <h3>Tape</h3>
          <ul>
            <li>Wny tapes?
              <ul class="fragment">
                <li>inherently hot-swappable</li>
                <li>cooler</li>
                <li>rugged</li>
                <li>fast sequential writes</li>
              </ul>
            </li>
            <li class="fragment">Two approaches:
              <ul class="fragment">
                <li>Meta-data at head, data afterward</li>
                <li>Meta-data interspersed with data</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Flash</h3>
          <ul>
            <li>Challenges / Features not addressed by existing FS:
              <ul class="fragment">
                <li>Blocks must be explicitly erased before written -- takes time</li>
                <li>Supports random access</li>
                <li>Wear leveling -- rewriting same block can wear out block</li>
              </ul>
            </li>
            <li class="fragment">Log structured file systems</li>
            <li class="fragment">Hardware vs software support erasing blocks / wear leveling</li>
          </ul>
        </section>

        <section>
          <h3>Network File Systems</h3>
          <ul>
            <li>Share folder / files across Network</li>
            <li>Benefits:
              <ul class="fragment">
                <li>Deduplication of data</li>
                <li>Shared home directories</li>
                <li>Convenient access to common files</li>
              </ul>
            </li>
            <li class="fragment">Challenges:
              <ul class="fragment">
                <li>Access permissions</li>
                <li>Where to store state</li>
                <li>Coherency</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>FUSE</h3>
          <ul>
            <li>File-System in User-Space</li>
            <li>Operations occur in a virtual file system</li>
            <li>Redirected toward user-space handler</li>
            <li>Able to write fully functional FS: NTFS, SSHFS</li>
          </ul>
        </section>

        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>A Look into Xv6</h3>
          <img src="images/xv6-fs.png" />
        </section>

        <section>
          <h3>System Calls</h3>
          <ul>
            <li>open</li>
            <li>close</li>
            <li>write</li>
            <li>read</li>
            <li>dup</li>
            <li>fstat</li>
            <li>mkdir</li>
            <li>chdir</li>
            <li>link</li>
            <li>unlink</li>
            <li>pipe</li>
          </ul>
        </section>

        <section>
          <h3>What we avoided</h3>
          <ul>
            <li>Writes</li>
            <li>Allocations</li>
            <li>The logging layer</li>
            <li>software / hardware IDE interface</li>
          </ul>
        </section>

        </section>
        <script type="text/javascript">writeOutline()</script>

        <section>
          <h3>Lab 4</h3>
          Lab 4a and b should be done<br />
          Lab 4 due 16 October<br />
        </section>

        <section>
          <h3>Next Time</h3>
          I/O and Drivers<br />
          Wednesday 1:00PM <br />
        </section>
			</div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
        slideNumber: true,
        margin: 0.0,
        minScale: 0.5,
        maxScale: 5.0,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-55655322-1', 'auto');
        ga('send', 'pageview');

    </script>

	</body>
</html>
