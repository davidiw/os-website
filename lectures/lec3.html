<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

    <title>CS422/522 - Lecture 1 - Introduction to Operating Systems</title>

    <meta name="description" content="Lecture 1 - Introduction to Operating Systems">
    <meta name="author" content="David Wolinsky">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'reveal.js/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

    <style>
      .reveal pre code { max-height: 700px; }
      .reveal pre { font-size: 70%; }
      .reveal p { text-align: left; }
    </style>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
          <h2>Virtual Memory</h2>
          <h3>CS422/522 Lecture 3</h3>
          <h3>3 September 2014</h3>
          <h4>Last updated: 3 September 2014</h4>
				</section>

        <section>
          <h3>Outline</h3>
          <ol>
            <li>Recap / Pointers</li>
            <li style="opacity: 0.4;">Overview of Memory</li>
            <li style="opacity: 0.4;">Memory Models</li>
            <li style="opacity: 0.4;">Sharing Memory</li>
            <li style="opacity: 0.4;">xv6 virtual memory</li>
            <li style="opacity: 0.4;">Wrap-Up</li>
          </ol>
        </section>

        <section>
          <section>
            <h3>Pointers</h3>
            Basic Pointers:
            <pre><code data-noescape="true" data-trim="true">
  int *x, y = 5, z = 7;
  x = &ampy; // x points to y
  *x = 6; // y now equals 6
  x = &ampz; // x points to the z
  *z = 3; // y = 6, z = 3
            </code></pre>
          </section>
          <section>
            <h3>Pointers</h3>
            Incrementing a pointer:
            <pre><code data-noescape="true" data-trim="true">
8534 ph = (struct proghdr*)((uchar*)elf + elf−>phoff);
8535 eph = ph + elf−>phnum;
8536 for(; ph < eph; ph++){
8537    pa = (uchar*)ph−>paddr;
8538    readseg(pa, ph−>filesz, ph−>off);
8539    if(ph−>memsz > ph−>filesz)
8540        stosb(pa + ph−>filesz, 0,
                ph−>memsz − ph−>filesz);
8541 }
            </code></pre>
          </section>
          <section>
            </h3>Pointers</h3>
            Function pointer:
            <pre><code data-noescape="true" data-trim="true">
8545 entry = (void(*)(void))(elf−&gtentry);
8546 entry();
            </code></pre>
          </section>
        </section>

        <section>
          <h3>The Kernel</h3>
          Lab 1 focuses on bootstrap and some hardware specific code<br />
          OS is layers of abstraction<br />
          <img height="300" src="images/os-structure.png" />
        </section>

        <section>
          <h3>Outline</h3>
          <ol>
            <li style="opacity: 0.4;">Recap / Pointers</li>
            <li>Overview of Memory</li>
            <li style="opacity: 0.4;">Memory Models</li>
            <li style="opacity: 0.4;">Sharing Memory</li>
            <li style="opacity: 0.4;">xv6 virtual memory</li>
            <li style="opacity: 0.4;">Wrap-Up</li>
          </ol>
        </section>

        <section>
          <h3>Introduction to Processes</h3>
          Executing application or program that (believes it) has full domain of an abstracted system. <br />
          <img height="300" src="images/os-structure.png" />

          <p />
          <p />

          <div class="fragment">
            In this lecture: Use memory to provide a portion of this abstraction --
            complete or near complete ownership of address space.
          </div>
        </section>

        <section>
          <h3>Memory Challenges</h3>
          <ul class="fragment">
            <li>Address bus &gt processor word size</li>
            <li>Protection / Isolation</li>
            <li>Fragmentation</li>
            <li>Sharing</li>
          </ul>
        </section>

        <section>
          <h3>x86 Memory Layout</h3>
          <img height="550" src="images/memory-layout.png" />
        </section>

        <section>
          <h3>Outline</h3>
          <ol>
            <li style="opacity: 0.4;">Recap / Pointers</li>
            <li style="opacity: 0.4;">Overview of Memory</li>
            <li>Memory Models</li>
            <li style="opacity: 0.4;">Sharing Memory</li>
            <li style="opacity: 0.4;">xv6 virtual memory</li>
            <li style="opacity: 0.4;">Wrap-Up</li>
          </ol>
        </section>

        <section>
          <h2>x86 Memory Models</h2>
          <ul>
            <li>Real mode with segmentation</li>
            <li>Protected mode with segmentation</li>
            <li>Protected mode with paging</li>
          </ul>
        </section>

        <section>
          <h3>x86 Real Mode</h3>
          <div style="width: 100%">
            <div style="width: 50%; float: left;">
              <ul>
                <li>8086 16-bit with 20-bit address bus</li>
                <li>Stored in segment registers: CS, DS, ES, FS</li>
                <li>Logical address - segment:offset</li>
                <li>Physical address - (segment * 0x10) + offset</li>
              </ul>
            </div>
            <div style="width: 50%; float: left;">
              <img src="images/realmode.png" />
            </div>
          </div>
        </section>

        <section>
          <h3>Real Mode Segmentation</h3>
          All except CS can be changed directly: <br />
            <pre><code data-noescape="true" data-trim="true">
mv $0xf000, %ds
pop %ds
          </code></pre>
          <div class="fragment">
            Changing the CS register: <br />
          <pre><code data-noescape="true">
jmp $0xf000, $0x10 # CS = $0xf000, EIP = $0xf0010
          </code></pre>
          </div>
        </section>

        <section>
          <h3>A 32-bit (64-bit) World</h3>
          In a 32-bit world, where address bus = word size,
          what can this form of segmentation do for us?
          <p />
          <div class="fragment">Not too much, moving logical address 0 away from the holes near real address 0.</div>
        </section>

        <section>
          <h3>x86 Protected Mode</h3>
          <div style="width: 100%">
            <div style="width: 50%; float: left;">
              <ul>
                <li>Memory isolation</li>
                <li>Privileged instructions</li>
              </ul> <br />
              <img src="images/protected-cs.png" />
              CPL - Current Privielge Level
            </div>
            <div style="width: 50%; float: left;">
              <img src="images/rings.png" />
            </div>
          </div>
        </section>

        <section>
          <h3>Protected Segmentation</h3>
          Segmentation registers become indexes into a table: <br />
          <ul>
            <li>Global descriptor table</li>
            <li>Local descriptor table</li>
            <li>Operating system vs Program</li>
          </ul>
          <br />
          <div class="fragment">
            <img src="images/desc-table.png" /> <br />
              <img src="images/protected-cs.png" />
          </div>
        </section>

        <section>
          <h3>Descriptor Format</h3>
          <img width="600" src="images/descriptor.png" />
          <ul>
            <li>G - 1B / 4KB Blocks</li>
            <li>Sz - 16 / 32 bit segment</li>
            <li>AVL - Available for use</li>
            <li>DPL - Descriptor Privilege Level</li>
            <li>P - Present</li>
            <li>S - System / Code or Data</li>
            <li>Ex - Data / Code</li>
            <li>RW - if Ex - R, if /Ex - W</li>
            <li>Ac - Accessed</li>
          </ul>
        </section>

        <section>
          <section>
            <h3>Enforcing Protection</h3>
            <div style="width: 100%">
              <div style="width: 30%; float: left;">
              <ul>
                <li>Type checking</li>
                <li style="visibility: hidden;">Limit checking</li>
                <li style="visibility: hidden;">Privilege levels</li>
              </ul>
              </div>
              <div style="width: 70%; float: left;">
                <img src="images/descriptor.png" /> <br />
                <ul>
                  <li>P - Present</li>
                  <li>S - System / Code or Data</li>
                  <li>Ex - Data / Code</li>
                  <li>RW - if Ex - R, if /Ex - W</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <h3>Enforcing Protection</h3>
            <div style="width: 100%">
              <div style="width: 30%; float: left;">
              <ul>
                <li>Type checking</li>
                <li>Limit checking</li>
                <li style="visibility: hidden;">Privilege levels</li>
              </ul>
              </div>
              <div style="width: 70%; float: left;">
                <img src="images/protectedmode.png" />
              </div>
            </div>
          </section>

          <section>
            <h3>Enforcing Protection</h3>
            <div style="width: 100%">
              <div style="width: 30%; float: left;">
              <ul>
                <li>Type checking</li>
                <li>Limit checking</li>
                <li>Privilege levels</li>
              </ul>
              </div>
              <div style="width: 70%; float: left;">
                <img src="images/privilege-check.png" />
              </div>
            </div>
          </section>
        </section>

        <section>
          <h3>Segmentation is great, right?</h3>
          <ul>
            <li>Must be physically backed</li>
            <li>May be fragmented</li>
            <li>Have to deal with memory holes</li>
          </ul>
        </section>

        <section>
          <h3>Paging</h3>
          <img src="images/page-table.png" />
        </section>

        <section>
          <h3>x86 Page Tables</h3>
          <img width="600" src="images/x86-pt.png" />
        </section>

        <section>
          <section>
            <h3>x86 Page Table in Depth</h3>
            <div style="width: 100%">
              <div style="width: 65%; float: left;">
                <img src="images/x86-linear.png" /><br />
                <ul>
                  <li>10 bits directory offset</li>
                  <li>10 bits table index</li>
                  <li>12 bits page offset</li>
                  <li>PTE / PDE 4 bytes</li>
                  <li>Directory / Table - 1024 entries</li>
                  <li>Page - 4 KB</li>
                </ul>
              </div>
              <div style="width: 35%; float: left;">
                <img width="600" src="images/x86-pt.png" />
              </div>
            </div>
          </section>
          <section>
            <h3>The Page Directory</h3>
            <div style="width: 100%">
              <div style="width: 65%; float: left;">
                <ul>
                  <li>CR3 - base address for directory.</li>
                  <li>Why more than one directory?
                    <span class="fragment">isolation / different views of memory</span></li>
                  </li>
                  <li>What type of control bits?
                    <div class="fragment">
                      <img src="images/x86-pde.png" /> <br />
                      <ul>
                        <li>S - 4KB / 4MB Page tables</li>
                        <li>A - Accessed</li>
                        <li>D - Disable cache</li>
                        <li>W - Enable write-through caching</li>
                        <li>U - Supervisor / User Page</li>
                        <li>RW - Enable writing</li>
                        <li>P - Present</li>
                      </ul>
                    </div>
                  </li>
                </ul>
              </div>
              <div style="width: 35%; float: left;">
                <img width="600" src="images/x86-pt.png" />
              </div>
            </div>
          </section>
          <section>
            <h3>The Page Table</h3>
            <div style="width: 100%">
              <div style="width: 65%; float: left;">
                <ul>
                  <li>Format:<br/>
                    <img src="images/x86-pte.png" /> <br />
                    <ul>
                      <li>G - Global</li>
                      <li>M - Modified</li>
                    </ul>
                  </li>
                  <li>PDE is basically a PTE, x86 2 layer page table</li>
                </ul>
              </div>
              <div style="width: 35%; float: left;">
                <img width="600" src="images/x86-pt.png" />
              </div>
            </div>
          </section>
          <section>
            <h3>The Page</h3>
            <div style="width: 100%">
              <div style="width: 65%; float: left;">
                <ul>
                  <li>Stored directly in memory</li>
                  <li>Everything is a page -- including page tables</li>
                  <li>How to access page tables?
                    <span class="fragment">Requires a conversion from physical to virtual</span></li>
                </ul>
              </div>
              <div style="width: 35%; float: left;">
                <img width="600" src="images/x86-pt.png" />
              </div>
            </div>
          </section>
        </section>

        <section>
          <h3>4 MB Pages</h3>
          <p>What changes happen if we use 4 MB pages instead of 4 KB?</p>
          <ul class="fragment">
            <li>No need to use page tables, merge PDE and PTE</li>
            <li>Performance</li>
          </ul>
          <li>More at <a href="http://www.rcollins.org/ddj/May96/">www.rcollins.org/ddj/May96/</a></li>
        </section>

        <section>
          <h3>Memory Guarding with Page Tables</h3>
          <ul>
            <li>Consider a stack grows without bound</li>
            <li>Eventually the stack runs out of space</li>
            <li>Triggers general protection exception -- accessed unallocated memory</li>
            <li>How to address in segmentation?
              <span class="fragment">Stack offers special handler,
                but other memory locations do not</span>
            </li>
            <li>Paging?
              <span class="fragment">Create a valid pte following allocated space,
                set present bit to 1</span>
            </li>
          </ul>
        </section>

        <section>
          <h3>Segmentation and/or Paging</h3>
          <ul>
            <li>Are paging and segmentation compatible? <span class="fragment">yes</span></li>
            <li>Features of segmentation?
              <ul class="fragment">
                <li>Course grained memory</li>
                <li>2 bits for privilege</li>
                <li>Cannot guard memory</li>
              </ul>
            </li>
            <li>Features of page tables?
              <ul class="fragment">
                <li>(Virtually) continuous memory</li>
                <li>Transparent</li>
                <li>(Nearly) Fixed size pages</li>
                <li>1 bit for privilege</li>
                <li>Memory guarding</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Outline</h3>
          <ol>
            <li style="opacity: 0.4;">Recap / Pointers</li>
            <li style="opacity: 0.4;">Overview of Memory</li>
            <li style="opacity: 0.4;">Memory Models</li>
            <li>Sharing Memory</li>
            <li style="opacity: 0.4;">xv6 virtual memory</li>
            <li style="opacity: 0.4;">Wrap-Up</li>
          </ol>
        </section>

        <section>
          <h3>Sharing Memory</h3>
          <div class="fragment">
            <ul>
              <li>Kernel shares certain data with processes</li>
              <li>Sharing of common code (libraries)</li>
              <li>Interprocess communication</li>
            </ul>
          </div>
          <div class="fragment">
            <p>Different ways of sharing?</p>
            <ul class="fragment">
              <li>Like a pipe</li>
              <li>Different permissions</li>
              <li>Same / different locations in memory</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Sharing a Segment</h3>
          <img src="images/descriptor.png" /> <br />
          <ul>
            <li>Libraries: common descriptor - same permissions, same base / limit</li>
            <li>Pipes: different descriptor - set W = 1, same base / limit</li>
            <li>OS data structures: different descriptor: set DPL 3/0, W=0/1, same base / limit</li>
          </ul>
        </section>

        <section>
          <h3>Sharing a Page</h3>
          <img src="images/x86-pte.png" /> <br />
          <ul>
            <li>Libraries: common pde, common pte - same permissions, same physical page base address</li>
            <li>Pipe: common pde, different pte - set W = 1, same physical page base address</li>
            <li>OS data structures: (maybe) different pde, different pte - set U,W = (0,1), (1,0),
              may be mapped to different addresses</li>
          </ul>
          <p>The final one cannot be done effectively in segmentation. Why?</p>
        </section>

        <section>
          <h3>Outline</h3>
          <ol>
            <li style="opacity: 0.4;">Recap / Pointers</li>
            <li style="opacity: 0.4;">Overview of Memory</li>
            <li style="opacity: 0.4;">Memory Models</li>
            <li style="opacity: 0.4;">Sharing Memory</li>
            <li>xv6 virtual memory</li>
            <li style="opacity: 0.4;">Wrap-Up</li>
          </ol>
        </section>

        <section>
          <h3>Compilation Process</h3>
          <img width="600" src="images/compilation.png" /><br />
          Compiler, assembler, linking, loading
        </section>

        <section>
          <h3>Last time</h3>
          <ul>
            <li>Loaded flat memory code and data descriptors</li>
            <li>Entered 32-bit protected mode</li>
            <li>Loaded kernel data into memory</li>
            <li>Called kernel entry point</li>
          </h3>
        </section>

        <section>
          <h3>Code Overview</h3>
          <ul>
            <li>Start paging with a temporary allocation</li>
            <li>Create real memory mapping in a new page table</li>
            <li>Enter new page table</li>
            <li>Enter new gdt with user and system descriptors</li>
          </ul>
        </section>

        <section>
          <section>
            <h3>Bootstrapping</h3>
            The first thing a kernel does is turn on paging...
            <pre><code data-noescape="true" data-trim="true">
1032 # By convention, the _start symbol specifies the ELF entry point.
1033 # Since we haven’t set up virtual memory yet, our entry point is
1034 # the physical address of ’entry’.
1035 .globl _start
1036 _start = V2P_WO(entry)
1037
1038 # Entering xv6 on boot processor, with paging off.
1039 .globl entry
1040 entry:
            </code></pre>
          </section>
          <section>
            <h3>Bootstrapping</h3>
            <pre><code data-noescape="true" data-trim="true">
1041 # Turn on page size extension for 4Mbyte pages
1042 movl %cr4, %eax
1043 orl $(CR4_PSE), %eax
1044 movl %eax, %cr4
1045 # Set page directory
1046 movl $(V2P_WO(entrypgdir)), %eax
1047 movl %eax, %cr3
1048 # Turn on paging.
1049 movl %cr0, %eax
1050 orl $(CR0_PG|CR0_WP), %eax
1051 movl %eax, %cr0
            </code></pre>
          </section>
          <section>
            <h3>Bootstrapping</h3>
            <pre><code data-noescape="true" data-trim="true">
1270 pde_t entrypgdir[]; // For entry.S
...
1306 // Boot page table used in entry.S and entryother.S.
1307 // Page directories (and page tables), must start on a page boundary,
1308 // hence the "__aligned__" attribute.
1309 // Use PTE_PS in page directory entry to enable 4Mbyte pages.
1310 __attribute__((__aligned__(PGSIZE)))
1311 pde_t entrypgdir[NPDENTRIES] = {
1312  // Map VA’s [0, 4MB) to PA’s [0, 4MB)
1313  [0] = (0) | PTE_P | PTE_W | PTE_PS,
1314  // Map VA’s [KERNBASE, KERNBASE+4MB) to PA’s [0, 4MB)
1315  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1316 };
            </code></pre>
          </section>
          <section>
            <h3>Bootstrapping</h3>
            <pre><code data-noescape="true">
1053 # Set up the stack pointer.
1054 movl $(stack + KSTACKSIZE), %esp
1055
1056 # Jump to main(), and switch to executing at
1057 # high addresses. The indirect call is needed because
1058 # the assembler produces a PC−relative instruction
1059 # for a direct jump.
1060 mov $main, %eax
1061 jmp *%eax
1062
1063 .comm stack, KSTACKSIZE
            </code></pre>
          </section>
        </section>
      </section>

        <section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1211 extern char end[]; // first address after kernel loaded from ELF file
...
1216 int
1217 main(void)
1218 {
1219  kinit1(end, P2V(4*1024*1024)); // phys page allocator
1220  kvmalloc(); // kernel page table
...
1223  seginit(); // set up segments
...
1238  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
...
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
2774 // Initialization happens in two phases.
2775 // 1. main() calls kinit1() while still using entrypgdir to place just
2776 // the pages mapped by entrypgdir on free list.
2777 // 2. main() calls kinit2() with the rest of the physical pages
2778 // after installing a full page table that maps them on all cores.
2779 void
2780 kinit1(void *vstart, void *vend)
2781 {
2782  initlock(&kmem.lock, "kmem");
2783  kmem.use_lock = 0;
2784  freerange(vstart, vend);
2785 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
2800 void
2801 freerange(void *vstart, void *vend)
2802 {
2803 char *p;
2804 p = (char*)PGROUNDUP((uint)vstart);
2805  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2806    kfree(p);
2807 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
2810 // Free the page of physical memory pointed at by v,
2811 // which normally should have been returned by a
2812 // call to kalloc(). (The exception is when
2813 // initializing the allocator; see kinit above.)
2814 void
2815 kfree(char *v)
2816 {
2817  struct run *r;
2819  if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
2820    panic("kfree");
...
2827  r = (struct run*)v;
2828  r−>next = kmem.freelist;
2829  kmem.freelist = r;
...
2832 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1754 // Allocate one page table for the machine for the kernel address
1755 // space for scheduler processes.
1756 void
1757 kvmalloc(void)
1758 {
1759  kpgdir = setupkvm();
1760  switchkvm();
1761 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1735 // Set up kernel part of a page table.
1736 pde_t*
1737 setupkvm(void)
1738 {
1739  pde_t *pgdir;
1740  struct kmap *k;
1741
1742  if((pgdir = (pde_t*)kalloc()) == 0)
1743    return 0;
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true" >
2834 // Allocate one 4096−byte page of physical memory.
2835 // Returns a pointer that the kernel can use.
2836 // Returns 0 if the memory cannot be allocated.
2837 char*
2838 kalloc(void)
2839 {
2840  struct run *r;
...
2844  r = kmem.freelist;
2845  if(r)
2846    kmem.freelist = r−>next;
...
2849  return (char*)r;
2850 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1736 pde_t*
1737 setupkvm(void)
...
1744  memset(pgdir, 0, PGSIZE);
1745  if (p2v(PHYSTOP) > (void*)DEVSPACE)
1746    panic("PHYSTOP too high");
1747  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1748    if(mappages(pgdir, k−>virt,
            k−>phys_end − k−>phys_start,
1749        (uint)k−>phys_start, k−>perm) < 0)
1750      return 0;
1751    return pgdir;
1752 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1723 static struct kmap {
1724  void *virt;
1725  uint phys_start;
1726  uint phys_end;
1727  int perm;
1728 } kmap[] = {
1729  { (void*)KERNBASE, 0, EXTMEM, PTE_W}, // I/O space
1730  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
1731  { (void*)data, V2P(data), PHYSTOP, PTE_W}, // kern data+memory
1732  { (void*)DEVSPACE, DEVSPACE, 0, PTE_W}, // more devices
1733 };
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1675 // Create PTEs for virtual addresses starting at va that refer to
1676 // physical addresses starting at pa. va and size might not
1677 // be page−aligned.
1678 static int
1679 mappages(pde_t *pgdir, void *va, uint size,
        uint pa, int perm)
1680 {
1681 char *a, *last;
1682 pte_t *pte;
1683
1684 a = (char*)PGROUNDDOWN((uint)va);
1685 last = (char*)PGROUNDDOWN(((uint)va) + size − 1);
1686 for(;;){
1687  if((pte = walkpgdir(pgdir, a, 1)) == 0)
1688    return −1;
...
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1650 // Return the address of the PTE in page table pgdir
1651 // that corresponds to virtual address va. If alloc!=0,
1652 // create any required page table pages.
1653 static pte_t *
1654 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1655 {
1656  pde_t *pde;
1657  pte_t *pgtab;
1659  pde = &pgdir[PDX(va)];
1660  if(*pde & PTE_P){
1661    pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
1662  } else {
1663    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1664      return 0;
1666    memset(pgtab, 0, PGSIZE);
1670    *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
1671  }
1672  return &pgtab[PTX(va)];
1673 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1678 static int
1679 mappages(pde_t *pgdir, void *va, uint size,
        uint pa, int perm)
...
1689    if(*pte & PTE_P)
1690      panic("remap");
1691    *pte = pa | perm | PTE_P;
1692    if(a == last)
1693      break;
1694    a += PGSIZE;
1695    pa += PGSIZE;
1696  }
1697  return 0;
1698 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1763 // Switch h/w page table register to the kernel−only page table,
1764 // for when no process is running.
1765 void
1766 switchkvm(void)
1767 {
1768  lcr3(v2p(kpgdir)); // switch to the kernel page table
1769 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
1613 // Set up CPU’s kernel segment descriptors.
1614 // Run once on entry on each CPU.
1615 void
1616 seginit(void)
1617 {
1618  struct cpu *c;
...
1624  c = &cpus[cpunum()];
1625  c−>gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1626  c−>gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1627  c−>gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1628  c−>gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
...
1633  lgdt(c−>gdt, sizeof(c−>gdt));
...
1639 }
            </code></pre>
          </section>
          <section>
            <h3>Setting up Virtual Memory</h3>
            <pre><code data-noescape="true" data-trim="true">
2787 void
2788 kinit2(void *vstart, void *vend)
2789 {
2790  freerange(vstart, vend);
2791  kmem.use_lock = 1;
2792 }
            </code></pre>
          </section>
        </section>
        <section>
          <h3>Wrap up</h3>
          <ul>
            <li>Used a temporary page of 4 MB</li>
            <li>Last portion was used to construct new page table</li>
            <li>Entered new page table</li>
            <li>Entered new gdt with user and system descriptors</li>
            <li>Mapped the kernel page tables</li>
          </ul>
        </section>
        <section>
          <h3>Outline</h3>
          <ol>
            <li style="opacity: 0.4;">Recap / Pointers</li>
            <li style="opacity: 0.4;">Overview of Memory</li>
            <li style="opacity: 0.4;">Memory Models</li>
            <li style="opacity: 0.4;">Sharing Memory</li>
            <li style="opacity: 0.4;">xv6 virtual memory</li>
            <li>Wrap-Up</li>
          </ol>
        </section>

        <section>
          <h3>Lab 1: Booting a PC</h3>
          <ul>
            <li>Due: 9/4 @ 11:59 PM</li>
            <li>10% penalty for each day late for up to 3 days</li>
          </ul>
        </section>

        <section>
          <h3>Lab 2: Memory Management</h3>
          <ul>
            <li>Due: 9/11 @ 11:59 PM</li>
            <li>Disabling segmentation</li>
            <li>Page table management</li>
            <li>Protecting the kernel</li>
          </ul>
        </section>

        <section>
          <h3>Systems Seminar</h3>
          Tuesdays at 11:45AM <br />
          AKW307 <br />
          Pizza <br />
          Please contact me if you intend to come <br />
        </section>

        <section>
          <h3>Next Time</h3>
          Monday 1:00PM <br />
          Using Virtual Memory<br />
        </section>
			</div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: false, 
        slideNumber: true,
        margin: 0.0,
        minScale: 0.2,
        maxScale: 5.0,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
